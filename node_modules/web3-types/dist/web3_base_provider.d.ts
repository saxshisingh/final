/// <reference types="node" />
import { Socket } from 'net';
import { Web3Error } from './error_types';
import { EthExecutionAPI } from './eth_execution_api';
import { JsonRpcNotification, JsonRpcPayload, JsonRpcResponse, JsonRpcResponseWithError, JsonRpcResponseWithResult, JsonRpcResult, JsonRpcSubscriptionResult } from './json_rpc_types';
import { Web3APISpec, Web3APIMethod, Web3APIReturnType, Web3APIPayload } from './web3_api_types';
declare const symbol: unique symbol;
export declare type Web3ProviderStatus = 'connecting' | 'connected' | 'disconnected';
export declare type Web3ProviderEventCallback<T = JsonRpcResult> = (error: Error | undefined, result?: JsonRpcSubscriptionResult | JsonRpcNotification<T>) => void;
export declare type Web3ProviderRequestCallback<ResultType = unknown> = (err?: Error | Web3Error | null | JsonRpcResponseWithError<Error>, response?: JsonRpcResponseWithResult<ResultType>) => void;
export interface LegacySendProvider {
    send<R = JsonRpcResult, P = unknown>(payload: JsonRpcPayload<P>, callback: (err?: Error | null, response?: JsonRpcResponse<R>) => void): void;
}
export interface LegacySendAsyncProvider {
    sendAsync<R = JsonRpcResult, P = unknown>(payload: JsonRpcPayload<P>): Promise<JsonRpcResponse<R>>;
}
export interface LegacyRequestProvider {
    request<R = JsonRpcResult, P = unknown>(payload: JsonRpcPayload<P>, callback: (err: Error | undefined, response: JsonRpcResponse<R>) => void): void;
}
export interface EIP1193Provider<API extends Web3APISpec> {
    request<Method extends Web3APIMethod<API>, ResponseType = Web3APIReturnType<API, Method>>(request: Web3APIPayload<API, Method>, requestOptions?: unknown): Promise<JsonRpcResponseWithResult<ResponseType>>;
}
export declare abstract class Web3BaseProvider<API extends Web3APISpec = EthExecutionAPI> implements LegacySendProvider, LegacySendAsyncProvider, EIP1193Provider<API> {
    static isWeb3Provider(provider: unknown): boolean;
    get [symbol](): boolean;
    abstract getStatus(): Web3ProviderStatus;
    abstract supportsSubscriptions(): boolean;
    send<R = JsonRpcResult, P = unknown>(payload: JsonRpcPayload<P>, callback: (err?: Error | null, response?: JsonRpcResponse<R>) => void): void;
    sendAsync<R = JsonRpcResult, P = unknown>(payload: JsonRpcPayload<P>): Promise<JsonRpcResponse<R, JsonRpcResult>>;
    abstract request<Method extends Web3APIMethod<API>, ResultType = Web3APIReturnType<API, Method>>(request: Web3APIPayload<API, Method>, requestOptions?: unknown): Promise<JsonRpcResponseWithResult<ResultType>>;
    abstract on<T = JsonRpcResult>(type: 'message' | 'disconnect' | string, callback: Web3ProviderEventCallback<T>): void;
    abstract on(type: 'connect' | 'chainChanged', callback: Web3ProviderEventCallback<{
        readonly [key: string]: unknown;
        readonly chainId: string;
    }>): void;
    abstract on(type: 'accountsChanged', callback: Web3ProviderEventCallback<{
        readonly [key: string]: unknown;
        readonly accountsChanged: string[];
    }>): void;
    abstract removeListener(type: string, callback: Web3ProviderEventCallback): void;
    abstract once?<T = JsonRpcResult>(type: string, callback: Web3ProviderEventCallback<T>): void;
    abstract removeAllListeners?(type: string): void;
    abstract connect(): void;
    abstract disconnect(code?: number, reason?: string): void;
    abstract reset(): void;
}
export declare type SupportedProviders<API extends Web3APISpec> = Web3BaseProvider<API> | EIP1193Provider<API> | LegacyRequestProvider | LegacySendProvider | LegacySendAsyncProvider;
export declare type Web3BaseProviderConstructor = new <API extends Web3APISpec>(url: string, net?: Socket) => Web3BaseProvider<API>;
export {};
//# sourceMappingURL=web3_base_provider.d.ts.map